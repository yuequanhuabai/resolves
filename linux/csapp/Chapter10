Part III  Interaction and Communication between Programs



Unix I/O
10.1 Unix I/O

linux 文件就是一系列字节组成;
所有的I/O设备，例如网络，磁盘，终端，都可以看成文件；所有的输入，输出都可以类比对文件的读写操作；

All I/O devices, such as network,disks, and terminals,are modeled as files,
and all input and output is performed by reading and writing the appropriate fiels.
This elegant mapping of devices to files allows the Linux I/O, that enables all input
and output to be performed in a uniform and consistent way:

Opening files:
应用程序访问I/O设备通过内核实现.内核返回一个小的非负整数，它就是文件描述符，它就是操作该文件的钥匙，有了它就可以对文件进行一系列的操作；
当然，这些操作是由内核提供的，内核记录着对该文件的所有操作记录信息，应用程序仅记录对文件描述符的操作。
The kernel keeps track of all information about the open file.
The application only keeps track of the descriptor.

应用程序--> 文件描述符
内核---> (系统api)实际操作文件

descriptor:
0 standard input
1 standard output
2 standard error


Changing the current file position
an applicatin can set the current file position k explicitly by performing a seek operation

Reading and writing files.

The kernel maintain a file position k ,initally 0, for each open file.

总结10.1 Unix I/O
linux里把 网络，磁盘，终端，读看作文件，
而所有的输入，输出看成对文件的读写操作即I/O
打开文件：文件描述符
改变当前文件的偏移offset： seek
读写文件： read，write
关闭文件：close ，内核释放内存数据，回收文件描述符到文件描述符池中。（异常关闭也是）



10.2 Files

linux和windows的文本行结束符
\n 和 \r\n

dos2unix
unix2dos

当前目录 .
上级目录 ..
相对路径，绝对路径

10.3 Opening and Closing Files
int open(char *filename, int flags, mode_t mode)
Returns: new file descriptor if OK,
-1 on error

filename: file descriptor
flags: the process intends to access the file:
(O_RDONLY. Reading only;O_WRONLY.Writing only;O_RDWR.Reading and writing)
mode: the access permission bits of new files
(S_IRUSR: [User(owner) can read this file],
S_IWUSR: [User (owner) can write thie file]
S_IXUSR: [User (owner) can execute this file])



10.4 Reading and Writing Files
文件读写
ssize_t read(int fd,void *buf, size_t n);
returns: number of bytes
read if OK, 0 on EOF, -1 on error
ssize_t wirte(int fd,const void *buf, size_t n);
returns: number of bytes
written if OK,  -1 on error

文件读写的的设计

size_t   unsigned long
ssize_t  long
返回数据理论上只有传入数据的一般，
long ，-2^63-2^63
unsigned long    0-2^64
实际为了返回-1异常，舍弃了理论的一半返回；

短计数发生的场景：
1.  文件只有20字节，实际读取50字节；
2. 从终端读取文本，read函数每次通常会读取一行文本，返回的即是读取的文本行的字节数
3. 读取网络socket，由于网络延迟或者内部缓冲限制而返回“短计数”


10.5 Robust Reading and Writing with the Rio package

