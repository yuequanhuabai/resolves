P於程join操作(分叉，R合)

Thread t =new  Thread(()->{
System.out.println("子程_始工作");
})

t.start();
t.join();

t.start();的意思是在@rgc上，t程闹骶程分叉_始绦;
t.join();的意思是主程在@r刻_始，等待t程绦校一直等待，直到t程绦薪Y束，主程u^m往下绦;

相的代a：
for (int i = 0; i < 5; i++) {
      Thread t = new Thread(task);
      t.start();
      t.join();
  }

t程_始绦校主程立刻_始了等待，等t程绦型戤，又_始了程程的绦校等待；主程循h等待每程绦型;

=====================================================================================================

List<Thread> threads = new ArrayList<>();
  for (int i = 0; i < 5; i++) {
      Thread t = new Thread(task);
      t.start();
      threads.add(t);
  }
  for (Thread t : threads) {
      t.join();    // ← 现在才等待
  }
 @代a的是，所有的子程首先_始绦校然後主程_始等待每程绦型戤;
 和上面代a的^e是所有的子程都_了绦校然後u是主程一一的等待他绦型辏主程在等待的^程中，其它子程也在绦;
 阻塞的^程就是主程等待其它子程绦型瓿傻倪@^程，主程等待的 s= 耗r最L的那子程的绦rg;
 子程通^start()分叉惆l绦校恢骶程通^join() 按序等待它绦型瓿;

你上面f的：
join的底舆是wait和notify
子程绦薪Y束後，{用notifyAll()去拘阎骶程；主程不是立刻@取到cpu的rg片;
t程run()绦薪Y束 --> JVM{用notifyAll() --> mainwaiting成了BLOCKED(等i) -->
@取到synchronizedi後，成了RUNNABLE(就w) --> 等待操作系y分配rg片 --> 真正绦(RUNNING)

@取到synchronizedi後，成了RUNNABLE(就w) --> 等待操作系y分配rg片(@步E是操作系y的步E，@取iK不等r於@取rg片，需要等待操作系y分配rg片,只有真正@取rg片，才绦芯程)
