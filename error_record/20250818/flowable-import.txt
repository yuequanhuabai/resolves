──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│  > 我現在理解了模型，定義，實例的關係，你可以講講flowable-demo這個demo項目裏面是如何利用RuntimeService和Tas │
│    kService這兩個對象實現了一個基本審批流嗎？                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

✦ 当然可以。我们结合 flowable-demo 的代码，把刚才的理论知识串联起来，走一遍完整的审批流程。

  这个过程就像一场由 Flowable 引擎导演，RuntimeService 和 TaskService 担任主角的话剧。

  ---

  第 0 幕：准备阶段 (应用启动)

   1. 当您的 Spring Boot 应用启动时，Flowable 引擎也随之启动。
   2. 引擎会自动扫描项目，发现了 resources/processes/one-task-process.bpmn20.xml 这个流程模型 (Model)。
   3. 引擎会解析这个模型，并在数据库中创建出一个带版本号的流程定义 (Definition)。
   4. 此时，万事俱备，舞台已搭好，但还没有任何流程在运行。

  ---

  第 1 幕：发起审批 (调用 `RuntimeService`)

   1. 用户操作： 您在前端点击 “Start New Process” 按钮。
   2. 代码执行： 后端的 ProcessController 调用了 startProcessInstance() 方法。
   3. 核心代码： runtimeService.startProcessInstanceByKey("oneTaskProcess");
   4. 背后发生的事：
       * RuntimeService 登场，它的角色是“流程实例管理员”。
       * 它接收到指令，根据 key 为 "oneTaskProcess" 的流程定义，创建出了一个流程实例 (Instance)。
       * 这个新创建的实例开始运行，它从【开始节点】出发，沿着流程图的箭头，走到了第一个节点——【User Task: My
         Task】。
       * 当实例进入这个人工任务节点时，引擎会说：“哦，这里需要人来处理”。于是它在数据库的任务表里创建了一个待
         办任务，并根据模型中的 flowable:assignee="demoUser"，把这个任务的负责人设置为 demoUser。
       * 做完这些后，这个流程实例就暂停在这里，静静地等待任务被完成。

  ---

  第 2 幕：查询待办 (调用 `TaskService`)

   1. 用户操作： 前端页面加载，需要显示待办任务列表。
   2. 代码执行： ProcessController 调用 getTasks() 方法。
   3. 核心代码： taskService.createTaskQuery().taskAssignee("demoUser").list();
   4. 背后发生的事：
       * TaskService 登场，它的角色是“待办任务管家”。
       * 它接收到查询指令，立刻去数据库的任务表中，把所有指派给 demoUser 的任务都找出来。
       * 它找到了刚才在第 1 幕中创建的那个“My Task”，然后把任务信息返回给前端展示。

  ---

  第 3 幕：完成审批 (再次调用 `TaskService`)

   1. 用户操作： 您在前端点击 “Complete” 按钮。
   2. 代码执行： ProcessController 调用 completeTask() 方法，并传入了要完成的任务 ID。
   3. 核心代码： taskService.complete(taskId);
   4. 背后发生的事：
       * “待办任务管家” (TaskService) 再次出马。它根据任务 ID
         找到这个待办任务，并将其状态标记为“已完成”（然后从运行时任务表移到历史任务表）。
       * 关键联动： 当任务被完成后，引擎会得到通知，之前那个暂停的流程实例被“唤醒”了。
       * 引擎会再次查看流程定义（设计图），看看【User Task】的下一步是什么。它发现箭头指向了【结束节点】。
       * 于是，流程实例继续前进，到达【结束节点】。当到达结束节点时，这个实例的使命就完成了，引擎会把它从运行
         时的数据库表中清理掉，并归档到历史记录中。
       * 至此，一个完整的审批流程结束。

  总结

  在这个 Demo 中，RuntimeService 和 TaskService 分工明确：

   * RuntimeService 只负责“从 0 到 1”，即根据模板（定义）启动一个全新的流程实例。
   * TaskService 则负责处理流程过程中的“人工交互”，包括查询谁有什么待办，以及处理这些待办。

  它们俩就像是左手和右手，由 Flowable 引擎这个大脑统一指挥，共同完成了一次审批。