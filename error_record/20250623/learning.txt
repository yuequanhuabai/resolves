下面從 **“編譯期 → 類加載期 → 運行期”** 的時間線，把 Java 最常用的「給一個類 加強（Enhance）」手段按層次梳理一遍，並簡要說明它們各自的原理、優缺點與適用場景。這些方式可以單獨用，也能混合使用——真正落地時往往是多種手段疊加。

---

### 1  語法級（編譯期）—最基本、最安全，也最受語言機制限制

| 手段                                   | 核心關鍵詞 / 技術                          | 一句話描述                                      | 優點                          | 侷限                      |
| ------------------------------------ | ----------------------------------- | ------------------------------------------ | --------------------------- | ----------------------- |
| **繼承 (Inheritance)**                 | `extends`                           | 子類繼承父類，通過重寫 (override) 或新增成員擴展行為           | 易理解；IDE 完整支援；性能幾乎無損         | 只能單繼承；強耦合；破壞封裝風險        |
| **實現接口 (Interfaces)**                | `implements`                        | 多實現 + Java 8 起接口可帶 `default` 方法，類似輕量 Mixin | 不破壞單繼承限制；可按需組合行為            | 只能聲明外部可見行為；無狀態共享；缺少私有字段 |
| **組合 / 委派 (Composition/Delegation)** | 成員變量 + 委派方法                         | 將被強化的對象作成員，外層包一層新功能                        | 更靈活；可在運行期切換被委派對象            | 需要重複包裝方法；調用鏈變長          |
| **裝飾者模式 (Decorator)**                | 經典設計模式                              | 遞歸包裝多層對象，動態組合功能                            | 不改動原類；可隨時拆卸                 | 類層級過深；調試定位稍難            |
| **註解處理器 (APT)**                      | `@interface` + Annotation Processor | 編譯時掃描註解，生成輔助/代理/配置代碼                       | 0 運行期開銷；Lombok、MapStruct 同款 | 僅能生成新文件；debug 需看生成碼     |

---

### 2  類載入期—對 .class 做文章

| 手段                                  | 入口 / 庫                         | 作用點              | 特點                         |                       |
| ----------------------------------- | ------------------------------ | ---------------- | -------------------------- | --------------------- |
| **字節碼增強 (Bytecode Enhancement)**    | ASM、Javassist、Byte Buddy、CGLIB | 修改、追加或生成新類；可替代繼承 | 功能最強；可繞開 `final`；但學習與維護成本高 |                       |
| **AspectJ Load-Time Weaving (LTW)** | `-javaagent:aspectjweaver.jar` | 類載入瞬間把切面織入目標類    | AOP 真·靜態植入；運行期零開銷          | 對部署、ClassLoader 配置較敏感 |

---

### 3  運行期—“動態”二字的魔法

| 手段                               | API / 框架                    | 適用目標        | 本質                                           | 典型場景                                 |
| -------------------------------- | --------------------------- | ----------- | -------------------------------------------- | ------------------------------------ |
| **JDK 動態代理**                     | `java.lang.reflect.Proxy`   | *僅接口*       | 生成匿名 `Proxy$xx` 類，方法統一轉到 `InvocationHandler` | RPC、Spring AOP (接口模式)                |
| **CGLIB / Byte Buddy 代理**        | 第三方庫                        | *具體類*       | 基於繼承動態衍生子類並覆蓋方法                              | Spring AOP (類模式)、MyBatis MapperProxy |
| **Java Agent + Instrumentation** | `premain/agentmain`         | 任意已載入或將載入類  | 熱插拔修改字節碼                                     | 性能監控、熱補丁                             |
| **JVMTI / Attach API**           | JVM 原生                      | JVM 層       | 低階調試、性能分析                                    | Profiler、內存分析                        |
| **反射 (Reflection)**              | `Field#setAccessible(true)` | 直接操作私有字段/方法 | 繞開訪問控制；臨時修改狀態                                | 單元測試、框架內部 SPI                        |

---

### 4  語義級—“業務視角”的擴展套路

* **AOP（面向切面編程）**：不論是 Spring AOP、AspectJ 還是 Quarkus、Micronaut 都屬於對「橫切關注點」的聲明式增強，自帶切點語法、聲明式事務、緩存等。
* **SPI / ServiceLoader**：把擴展點抽成接口，第三方通過 META-INF/services 註冊實現；JDBC、JUL 日誌框架都用這招。
* **事件 / 觀察者模式**：發佈–訂閱機制在不改動核心類的情況下可讓多個增強邏輯並行存在。
* **函數式鏈式 API（Java 8 Lambda、Stream、RxJava、Reactor）**：用行為參數化 (Behavior Parameterization) 把“擴展”轉為函數注入。

---

## 綜合選型參考

| 考量                    | 偏向方案                           |
| --------------------- | ------------------------------ |
| **最小學習曲線**            | 繼承 + 組合 + 裝飾                   |
| **高效能、無運行期開銷**        | APT / 編譯期織入 (AspectJ CTW)      |
| **動態能力、熱插拔**          | 動態代理 + Byte Buddy / Java Agent |
| **細粒度橫切 (如日誌、權限、事務)** | AOP (Spring AOP / AspectJ)     |
| **插件化、可插拔架構**         | SPI + ServiceLoader + 事件機制     |

---

### 小結

> **Java 的“類增強”並非單一技術，而是一整條從語法到 JVM 低層的梯度。**
>
> * 初學時先掌握“繼承／組合／裝飾”三板斧；
> * 進階後學會“動態代理 + AOP”處理橫切關注點；
> * 需要極致靈活與性能時，再考慮“字節碼增強 / Java Agent”。

掌握了這些手段，你就能針對不同需求在**可維護性 ↔ 靈活度 ↔ 性能**之間找到最合適的平衡點。
