 ---
  一、编码与换行符问题

  1. BOM 头（最常见的隐形坑）

  Windows 下用记事本或 SSMS 导出的 SQL 文件，文件开头经常带 UTF-8 BOM（EF BB BF，3个不可见字节）。

  # 看起来是空行，实际第一行前面有隐藏字符
  $ cat -A script.sql
  M-oM-;M-?DROP TABLE users   # ← BOM 导致第一行关键字匹配失败

  影响：grep "^DROP" 永远匹配不到第一行的 DROP。

  2. 换行符 CRLF vs LF

  Windows 编辑器产出的文件用 \r\n，Linux 上 \r 会残留成行内容的一部分。

  # 看起来正常，但行尾有隐藏的 \r
  $ cat -A script.sql
  GO^M$            # ← \r 导致 GO 匹配失败

  影响：GO\r 不等于 GO，分隔符检测和关键字匹配全部失效。

  3. UTF-16 编码

  SQL Server Management Studio 有时导出 UTF-16LE 编码的文件，grep/sed 默认无法处理。

  ---
  二、SQL 语法层面的隐藏问题

  4. 关键字被拆到多行

  DROP
      TABLE
      users
  GO

  单行 grep "DROP TABLE" 匹配不到。需要拼接完整语句后再匹配。

  5. 动态 SQL — 危险操作藏在字符串里

  EXEC sp_executesql N'DROP TABLE users'

  DECLARE @sql NVARCHAR(MAX) = 'DELETE FROM users'
  EXEC(@sql)

  -- 更隐蔽：拼接
  SET @sql = 'DROP ' + 'TABLE ' + 'users'

  这是最难检测的场景。关键字在字符串内部，常规正则会把它当成"字符串字面量"忽略掉——但它实际会执行。

  6. 字符串字面量的误报 vs 漏报矛盾

  -- 场景A：应忽略（纯字符串值，不会执行）
  INSERT INTO logs (msg) VALUES (N'用户执行了 DROP TABLE')

  -- 场景B：不能忽略（会被执行！）
  EXEC(N'DROP TABLE users')

  两种都是字符串里包含 DROP TABLE，但含义完全不同。简单的字符串排除策略会漏掉场景B。

  7. 同义语法 / 简写

  SQL Server 中同一操作有多种写法：
  ┌──────────────────────┬─────────────────────────────────────┐
  │       标准写法       │                变体                 │
  ├──────────────────────┼─────────────────────────────────────┤
  │ BEGIN TRANSACTION    │ BEGIN TRAN                          │
  ├──────────────────────┼─────────────────────────────────────┤
  │ DELETE FROM table    │ DELETE table（FROM 可省略）         │
  ├──────────────────────┼─────────────────────────────────────┤
  │ EXEC sp_xxx          │ EXECUTE sp_xxx                      │
  ├──────────────────────┼─────────────────────────────────────┤
  │ DROP TABLE IF EXISTS │ IF EXISTS(...) DROP TABLE（老语法） │
  ├──────────────────────┼─────────────────────────────────────┤
  │ TRUNCATE TABLE       │ 无变体，但注意大小写混合            │
  └──────────────────────┴─────────────────────────────────────┘
  你的 Java 代码里的 data_init.sql 用的就是老语法 IF EXISTS(SELECT...) DROP TABLE，而 create_table_base.sql 用的是新语法 DROP TABLE IF EXISTS。两种都要匹配。

  8. 存储过程/函数体内的危险操作

  CREATE PROCEDURE sp_cleanup
  AS
  BEGIN
      DELETE FROM temp_table    -- ← 这是定义，不是直接执行
      DROP TABLE old_backup     -- ← 同上
  END
  GO

  这种情况需要区分：是在定义存储过程，还是在直接执行 SQL。定义体内的危险操作风险级别应降低，因为创建存储过程本身不会执行里面的 DELETE/DROP。

  9. 注释符在字符串内

  INSERT INTO config (val) VALUES ('连接符号--用于分隔')

  -- 出现在字符串 '...' 里，不是注释。如果简单按 -- 截断行内容，这行的后半部分会被误切掉。

  ---
  三、Shell 处理层面的坑

  10. 超大文件

  你的 ruoyi-vue-pro.sql 或 converted_sqlserver.sql 可能很大。逐行读取没问题，但如果把整个文件读进一个变量（如 content=$(cat file.sql)），在 bash 中会有内存和性能问题。

  11. SQL 内容包含 Shell 特殊字符

  INSERT INTO config (val) VALUES ('price=$100 & quantity>0')

  如果在 Shell 中用 echo 或变量替换处理这行，$100 会被 Shell 解释为变量，> 会被解释为重定向。需要始终用双引号包裹变量、避免 eval。

  12. 文件名含空格或特殊字符

  sql scripts/create table.sql

  for f in *.sql 遍历时如果文件名含空格会断裂。需要用 while IFS= read -r 或 find ... -print0 | while 处理。

  ---
  四、汇总：脚本需要增加的防护
  ┌───────────────────────────┬───────────────────────────────────────────────────────────────────────────┐
  │           问题            │                                 处理方案                                  │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ BOM 头                    │ 预处理阶段用 sed 去除 \xEF\xBB\xBF                                        │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ CRLF 换行                 │ 预处理阶段用 tr -d '\r' 或 sed 's/\r$//'                                  │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ UTF-16 编码               │ 检测到时用 iconv 转 UTF-8，或直接报错提示                                 │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ 关键字跨行                │ 拼接完整语句后再匹配，不能只做单行 grep                                   │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ 动态 SQL                  │ EXEC( / sp_executesql 内的字符串参数也要扫描关键字，单独标记为 HIGH       │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ 字符串字面量              │ 对 INSERT/UPDATE ... VALUES 中的字面量忽略；对 EXEC(...) 中的字面量不忽略 │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ IF EXISTS + DROP 老语法   │ 匹配 IF\s+EXISTS\s*\(.*\)\s*DROP 模式                                     │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ DELETE table（省略 FROM） │ 匹配 DELETE\s+(?!FROM)\w+                                                 │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ 存储过程体                │ 检测到 `CREATE\s+(PROCEDURE                                               │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ 注释符在字符串内          │ 只对引号外的 -- 做注释截断                                                │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Shell 特殊字符            │ 变量全部加双引号，避免 eval                                               │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ 文件名空格                │ 用 find ... -print0 + while read                                          │
  ├───────────────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ 大文件                    │ 逐行流式处理，不读入变量                                                  │
  └───────────────────────────┴───────────────────────────────────────────────────────────────────────────┘
  ---
  这些是我能想到的所有隐藏问题。你看看还有没有其他顾虑，没有的话我开始写脚本。
