
● PAP 前端项目架构分析

  一、项目概览

  | 项目     | 说明                                    |
  |----------|-----------------------------------------|
  | 项目名称 | PAP (Process Application Platform) 前端 |
  | 技术栈   | Vue 3.5 + TypeScript 5.3 + Vite 5.4     |
  | UI 框架  | Element Plus 2.9                        |
  | 状态管理 | Pinia 2.1                               |
  | 路由     | Vue Router 4.4                          |
  | CSS 方案 | UnoCSS + SCSS                           |

  ---
  二、目录结构

  poc-pro-ui/
  ├── build/                    # Vite 构建配置
  ├── src/
  │   ├── main.ts              # 应用入口
  │   ├── App.vue              # 根组件
  │   ├── permission.ts        # 路由权限守卫
  │   ├── api/                 # API 接口层（按模块划分）
  │   ├── components/          # 全局组件库（40+ 个）
  │   ├── config/axios/        # Axios 请求封装
  │   ├── directives/          # 自定义指令（权限等）
  │   ├── hooks/               # Composition API Hooks
  │   ├── layout/              # 布局组件
  │   ├── locales/             # 国际化（中/英）
  │   ├── plugins/             # 插件（Element Plus、i18n 等）
  │   ├── router/              # 路由配置
  │   ├── store/modules/       # Pinia 状态模块
  │   ├── styles/              # 全局样式
  │   ├── types/               # TypeScript 类型定义
  │   ├── utils/               # 工具函数库
  │   └── views/               # 页面视图
  ├── vite.config.ts           # Vite 配置
  ├── tsconfig.json            # TypeScript 配置
  └── uno.config.ts            # UnoCSS 配置

  ---
  三、核心模块

  1. 状态管理 (store/modules/)

  | Store         | 职责                     |
  |---------------|--------------------------|
  | app.ts        | 界面配置、主题、布局     |
  | user.ts       | 用户信息、权限列表、角色 |
  | permission.ts | 动态路由生成             |
  | dict.ts       | 数据字典缓存             |
  | locale.ts     | 国际化状态               |
  | tagsView.ts   | 标签页管理               |

  2. 请求层 (config/axios/)

  - service.ts: Axios 实例和拦截器
  - 自动添加 Token 和租户 ID
  - 无感知 Token 刷新机制
  - 统一错误处理

  3. 权限指令 (directives/)

  <!-- 按钮权限 -->
  <el-button v-hasPermi="['system:user:create']">新增</el-button>

  <!-- 角色权限 -->
  <el-button v-hasRole="['admin']">管理员操作</el-button>

  4. 布局系统 (layout/)

  支持 4 种布局模式：
  - classic: 经典侧边菜单
  - topLeft: 顶部左侧
  - top: 纯顶部
  - cutMenu: 切割菜单

  ---
  四、业务模块 (views/)

  views/
  ├── Home/           # 首页
  ├── Login/          # 登录
  ├── system/         # 系统管理（用户、角色、权限）
  ├── bpm/            # BPM 工作流
  │   ├── category/   # 流程分类
  │   ├── model/      # 流程模型
  │   ├── task/       # 任务管理
  │   └── processInstance/  # 流程实例
  ├── benchmark/      # 基准管理
  ├── buylist/        # 采购清单
  └── modelportfolio/ # 模型组合

  ---
  五、关键特性

  BPM 工作流

  - 集成 bpmn-js 17.9 BPMN 编辑器
  - 支持流程设计、部署、实例管理

  动态表单

  - @form-create/designer 可视化表单设计
  - 支持拖拽配置表单

  组件库（40+）

  - Form/Table/Dialog 通用组件
  - Editor 富文本（WangEditor）
  - Echart 图表封装
  - bpmnProcessDesigner 流程设计器

  国际化

  - 中/英双语支持
  - useI18n() Hook 调用

  ---
  六、应用启动流程

  main.ts
    ↓ setupI18n()        国际化
    ↓ setupStore()       Pinia
    ↓ setupElementPlus() UI 组件
    ↓ setupFormCreate()  动态表单
    ↓ setupRouter()      路由
    ↓ setupAuth()        权限指令
    ↓ app.mount('#app')  挂载

  ---
  七、开发命令

  npm run dev           # 本地开发 (http://localhost:8080)
  npm run build:prod    # 生产构建
  npm run lint:eslint   # 代码检查
  npm run lint:format   # 格式化代码

  ---
  八、与后端对接

  - API 基础路径: /admin-api
  - 请求封装: src/config/axios/
  - 响应格式: 统一 CommonResult<T> 结构
  - Token 存储: localStorage (wsCache)

  ---
  这是一个功能完善的企业级后台管理系统前端，基于 Yudao 框架，具备完整的权限管理、BPM 工作流、动态表单、多语言等企业级特性。

> 可以详细讲讲：permission.ts文件吗？

● Read(poc-pro-ui\src\permission.ts)
  ⎿  Read 111 lines

● permission.ts 详解

  这是路由权限守卫文件，控制页面访问权限和初始化流程。

  ---
  一、文件结构概览

  permission.ts
  ├── 依赖导入 (1-10行)
  ├── 工具函数 parseURL (16-47行)
  ├── 白名单配置 (50-56行)
  ├── 前置守卫 beforeEach (59-104行)
  └── 后置守卫 afterEach (106-110行)

  ---
  二、依赖导入

  import router from './router'                    // Vue Router 实例
  import { isRelogin } from '@/config/axios/service'  // 重新登录标识
  import { getAccessToken, setSamlToken } from '@/utils/auth'  // Token 工具
  import { useTitle } from '@/hooks/web/useTitle'     // 页面标题
  import { useNProgress } from '@/hooks/web/useNProgress'  // 顶部进度条
  import { usePageLoading } from '@/hooks/web/usePageLoading'  // 页面加载
  import { useDictStoreWithOut } from '@/store/modules/dict'   // 字典 Store
  import { useUserStoreWithOut } from '@/store/modules/user'   // 用户 Store
  import { usePermissionStoreWithOut } from '@/store/modules/permission'  // 权限 Store

  ---
  三、工具函数 parseURL

  const parseURL = (url: string | null | undefined): {
    basePath: string;
    paramsObject: { [key: string]: string }
  } => {
    // 解析 URL，分离路径和查询参数
    // 例如: "/user?id=1&name=test"
    // → { basePath: "/user", paramsObject: { id: "1", name: "test" } }
  }

  用途: 处理登录后的重定向，保留原始 URL 的查询参数。

  ---
  四、白名单配置

  const whiteList = [
    '/login',           // 登录页
    '/auth-redirect',   // 认证重定向
    '/bind',            // 绑定页
    '/register',        // 注册页
    '/oauthLogin/gitee' // OAuth 登录
  ]

  作用: 这些路由无需登录即可访问。

  ---
  五、前置守卫 beforeEach 流程图

  ┌─────────────────────────────────────────────────────────────┐
  │                    路由导航开始                              │
  │                         ↓                                   │
  │            start() + loadStart()  启动进度条                 │
  │                         ↓                                   │
  │              URL 中有 token 参数？                           │
  │              ├─ 是 → setSamlToken() 保存                    │
  │              └─ 否 → 继续                                   │
  │                         ↓                                   │
  │              getAccessToken() 有 Token？                    │
  │              ├─────────────────────────────────────────┐    │
  │              │                                         │    │
  │              ↓ 有 Token                                ↓ 无 │
  │      目标是 /login？                          在白名单中？   │
  │      ├─ 是 → next('/') 跳首页               ├─ 是 → next() │
  │      └─ 否 → 检查初始化                      └─ 否 → 跳登录 │
  │              ↓                                              │
  │      字典已加载？ (!dictStore.getIsSetDict)                  │
  │      └─ 否 → dictStore.setDictMap()                         │
  │              ↓                                              │
  │      用户已加载？ (!userStore.getIsSetUser)                  │
  │      ├─ 是 → next() 直接放行                                │
  │      └─ 否 → 执行初始化流程 ↓                               │
  │              ↓                                              │
  │      1. userStore.setUserInfoAction()  加载用户信息          │
  │      2. permissionStore.generateRoutes() 生成动态路由        │
  │      3. router.addRoute() 添加路由到路由表                   │
  │      4. next() 跳转（保留重定向参数）                        │
  │                                                             │
  └─────────────────────────────────────────────────────────────┘

  ---
  六、核心逻辑详解

  1. SAML Token 处理 (62-66行)

  const urlToken = to.query.token as string
  if (urlToken) {
    setSamlToken(urlToken)  // 支持 SAML SSO 单点登录
  }

  场景: 从第三方认证系统回调时，URL 携带 token。

  2. 已登录用户访问 /login (68-69行)

  if (to.path === '/login') {
    next({ path: '/' })  // 已登录就跳首页，不让再访问登录页
  }

  3. 首次加载初始化 (75-92行)

  // 1. 加载字典数据
  if (!dictStore.getIsSetDict) {
    await dictStore.setDictMap()
  }

  // 2. 加载用户信息（首次）
  if (!userStore.getIsSetUser) {
    isRelogin.show = true  // 显示重新登录遮罩
    await userStore.setUserInfoAction()  // 获取用户信息+权限
    isRelogin.show = false

    // 3. 生成动态路由
    await permissionStore.generateRoutes()

    // 4. 动态添加路由
    permissionStore.getAddRouters.forEach((route) => {
      router.addRoute(route as unknown as RouteRecordRaw)
    })

    // 5. 处理重定向（保留查询参数）
    const redirectPath = from.query.redirect || to.path
    const redirect = decodeURIComponent(redirectPath as string)
    const { paramsObject: query } = parseURL(redirect)
    const nextData = to.path === redirect
      ? { ...to, replace: true }
      : { path: redirect, query }
    next(nextData)
  }

  4. 未登录处理 (97-103行)

  if (whiteList.indexOf(to.path) !== -1 || getAccessToken()) {
    next()  // 白名单放行
  } else {
    next(`/login?redirect=${to.fullPath}`)  // 跳登录，记录原目标
  }

  ---
  七、后置守卫 afterEach

  router.afterEach((to) => {
    useTitle(to?.meta?.title as string)  // 设置页面标题
    done()      // 结束顶部进度条
    loadDone()  // 结束页面加载动画
  })

  ---
  八、完整流程时序图

  用户访问 /dashboard
          │
          ▼
     beforeEach 触发
          │
          ▼
     ┌─ 检查 Token ─┐
     │              │
     │ 有 Token     │ 无 Token
     ▼              ▼
  检查用户信息    跳转 /login?redirect=/dashboard
     │
     ▼
  首次访问？
     │
     ├─ 是 ──────────────────────────┐
     │                               │
     │  1. 加载字典 dictStore        │
     │  2. 加载用户 userStore        │
     │  3. 生成路由 permissionStore  │
     │  4. router.addRoute()         │
     │                               │
     └───────────────────────────────┘
     │
     ▼
   next() 放行
          │
          ▼
     afterEach 触发
          │
          ▼
     设置标题 + 结束进度条
          │
          ▼
     页面渲染完成

  ---
  九、关键点总结

  | 功能         | 说明                               |
  |--------------|------------------------------------|
  | 白名单机制   | 登录/注册等页面无需认证            |
  | 动态路由     | 根据后端返回的菜单权限动态生成路由 |
  | 懒加载初始化 | 只在首次访问时加载字典、用户、路由 |
  | 重定向保持   | 登录后跳回原目标页，保留查询参数   |
  | SAML SSO     | 支持 URL 携带 token 的单点登录     |
  | 进度反馈     | 顶部进度条 + 页面加载动画          |

  这个文件是整个前端权限控制的核心，确保用户只能访问有权限的页面。



