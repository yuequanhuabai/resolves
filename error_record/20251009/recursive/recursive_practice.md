# 递归算法练习题集

> 通过实际训练掌握递归的应用！从简单到复杂逐步提升，每个难度级别包含5道精选题目。

---

## 一、简单难度（入门级）

### 1.1 计算阶乘
**问题描述：**
编写一个递归函数，计算给定整数 `n` 的阶乘（n!）。

**输入：** 整数 n（0 ≤ n ≤ 20）
**输出：** n 的阶乘值
**示例：**
- 输入：5 → 输出：120（5! = 5×4×3×2×1）
- 输入：0 → 输出：1

**相关概念：** 基础递归，边界条件

---

### 1.2 计算斐波那契数列
**问题描述：**
编写递归函数计算斐波那契数列的第 `n` 项，其中 F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)。

**输入：** 整数 n（0 ≤ n ≤ 35）
**输出：** 第 n 项的值
**示例：**
- 输入：6 → 输出：8（数列：0,1,1,2,3,5,8...）
- 输入：10 → 输出：55

**相关概念：** 递归的重复计算问题

---

### 1.3 数组求和
**问题描述：**
编写递归函数计算数组中所有元素的和。

**输入：** 数组 arr，数组长度 n
**输出：** 数组元素之和
**示例：**
- 输入：[1, 2, 3, 4, 5] → 输出：15
- 输入：[10, 20, 30] → 输出：60

**相关概念：** 递归处理数组，递归指针移动

---

### 1.4 打印数字到字符串
**问题描述：**
编写递归函数，将一个正整数的每一位数字都打印出来（每行一个）。

**输入：** 正整数 n
**输出：** 每一位数字（按顺序打印）
**示例：**
- 输入：12345 → 输出：
  ```
  1
  2
  3
  4
  5
  ```

**相关概念：** 递归与副作用，数值分解

---

### 1.5 查找数组中的最大值
**问题描述：**
编写递归函数找出数组中的最大值。

**输入：** 数组 arr，数组长度 n
**输出：** 数组中的最大值
**示例：**
- 输入：[3, 7, 2, 9, 1] → 输出：9
- 输入：[10] → 输出：10

**相关概念：** 递归比较，问题规模缩小

---

## 二、中等难度（基础进阶）

### 2.1 反转字符串
**问题描述：**
编写递归函数，将给定的字符串反转（不使用内置反转函数）。

**输入：** 字符串 s
**输出：** 反转后的字符串
**示例：**
- 输入："hello" → 输出："olleh"
- 输入："abc" → 输出："cba"

**相关概念：** 字符串分割，递归回溯

---

### 2.2 二分查找
**问题描述：**
编写递归函数，在有序数组中实现二分查找。

**输入：** 有序数组 arr，目标值 target，左右边界 left, right
**输出：** 目标值的索引（不存在返回 -1）
**示例：**
- 输入：[1, 3, 5, 7, 9], target=5 → 输出：2
- 输入：[1, 3, 5, 7, 9], target=4 → 输出：-1

**相关概念：** 分治思想，递归的效率优化

---

### 2.3 计算数组中的最小值
**问题描述：**
编写递归函数找出数组中的最小值。也可以进一步扩展为同时找最大值和最小值。

**输入：** 数组 arr，数组长度 n
**输出：** 数组中的最小值
**示例：**
- 输入：[5, 2, 8, 1, 9] → 输出：1
- 输入：[100] → 输出：100

**相关概念：** 递归比较，多条件判断

---

### 2.4 判断字符串是否为回文
**问题描述：**
编写递归函数，判断给定字符串是否是回文（正反读一样）。

**输入：** 字符串 s
**输出：** 布尔值（true 为回文，false 为非回文）
**示例：**
- 输入："racecar" → 输出：true
- 输入："hello" → 输出：false
- 输入："a" → 输出：true

**相关概念：** 递归验证，字符串操作

---

### 2.5 计算字符串长度
**问题描述：**
编写递归函数计算字符串的长度（不使用内置 length 方法）。

**输入：** 字符串 s
**输出：** 字符串长度
**示例：**
- 输入："hello" → 输出：5
- 输入："" → 输出：0

**相关概念：** 基础递归，逐字符遍历

---

## 三、高等难度（思维进阶）

### 3.1 树的遍历（前序遍历）
**问题描述：**
给定一棵二叉树，编写递归函数实现前序遍历（根→左→右），并返回遍历结果的数组。

**输入：** 二叉树根节点
**输出：** 前序遍历的节点值数组
**示例：**
```
    1
   / \
  2   3
```
输出：[1, 2, 3]

**相关概念：** 递归遍历，树的操作

---

### 3.2 爬楼梯问题
**问题描述：**
你正在爬楼梯，每次可以爬 1 步或 2 步。给定楼梯总数 `n`，有多少种不同的方法到达楼顶？

**输入：** 整数 n（楼梯数）
**输出：** 不同爬法的总数
**示例：**
- 输入：2 → 输出：2（1+1 或 2）
- 输入：3 → 输出：3（1+1+1、1+2、2+1）
- 输入：4 → 输出：5（1+1+1+1、1+1+2、1+2+1、2+1+1、2+2）

**相关概念：** 递归与动态规划，组合问题

---

### 3.3 集合的所有子集
**问题描述：**
给定一个集合，编写递归函数生成该集合的所有子集（幂集）。

**输入：** 数组 arr（代表集合元素）
**输出：** 所有子集组成的二维数组
**示例：**
- 输入：[1, 2] → 输出：[[], [1], [2], [1,2]]
- 输入：[1, 2, 3] → 输出：[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]

**相关概念：** 回溯法，组合生成

---

### 3.4 字符串的所有排列
**问题描述：**
给定一个字符串，编写递归函数生成该字符串的所有排列（不考虑重复字符）。

**输入：** 字符串 s
**输出：** 所有排列组成的数组
**示例：**
- 输入："AB" → 输出：["AB", "BA"]
- 输入："ABC" → 输出：["ABC", "ACB", "BAC", "BCA", "CAB", "CBA"]

**相关概念：** 回溯法，递归枚举

---

### 3.5 计算 n 的所有因子
**问题描述：**
编写递归函数找出给定正整数 `n` 的所有因子（能整除 n 的数）。

**输入：** 正整数 n
**输出：** 所有因子组成的数组
**示例：**
- 输入：12 → 输出：[1, 2, 3, 4, 6, 12]
- 输入：28 → 输出：[1, 2, 4, 7, 14, 28]

**相关概念：** 递归搜索，数学运算

---

## 四、困难难度（综合挑战）

### 4.1 汉诺塔问题
**问题描述：**
有 3 根柱子 A、B、C，以及 n 个不同大小的圆盘。初始时所有圆盘都在柱子 A 上（大盘在下，小盘在上）。目标是将所有圆盘移动到柱子 C 上，要求：
- 每次只能移动一个圆盘
- 任何时刻，大盘不能在小盘的上面

编写递归函数打印出移动步骤。

**输入：** 圆盘数量 n
**输出：** 每一步的移动操作（如："A→C"）
**示例：**
- 输入：2 → 输出：
  ```
  A → B
  A → C
  B → C
  ```
- 输入：3 → 输出 8 步移动

**相关概念：** 经典递归问题，分治策略，指数级复杂度

---

### 4.2 N 皇后问题
**问题描述：**
在 n×n 的国际象棋棋盘上放置 n 个皇后，使得它们互不攻击（任意两个皇后不在同一行、同一列或同一对角线上）。编写递归函数找出所有解。

**输入：** 棋盘大小 n
**输出：** 所有合法的皇后放置方案
**示例：**
- 输入：4 → 输出：2 种解法（共有 92 种解法）
- 输入：1 → 输出：1 种解法

**相关概念：** 回溯法，约束满足问题，递归搜索树

---

### 4.3 最长公共子序列（LCS）
**问题描述：**
给定两个字符串，编写递归函数找出它们的最长公共子序列的长度。

**输入：** 两个字符串 s1, s2
**输出：** 最长公共子序列的长度
**示例：**
- 输入：s1="ABCDGH", s2="AEDFHR" → 输出：3（"ADH" 是最长公共子序列）
- 输入：s1="ABC", s2="DEF" → 输出：0

**相关概念：** 递归动态规划，序列比较

---

### 4.4 将字符串中的空格转换为特定字符（URL 编码模拟）
**问题描述：**
给定一个字符串和其真实长度，将字符串中的每个空格递归地转换为 "%20"（或其他指定字符），并且要在原字符串中进行修改（模拟原地修改）。

**输入：** 字符串 str，原始长度 len（可能包含预留空间）
**输出：** 修改后的字符串
**示例：**
- 输入："Mr John Smith" → 输出："Mr%20John%20Smith"
- 输入："a b c" → 输出："a%20b%20c"

**相关概念：** 递归字符串处理，指针操作

---

### 4.5 正则表达式匹配（简化版）
**问题描述：**
实现一个简化的正则表达式匹配函数，支持 '.' 和 '*' 两个特殊字符：
- '.' 匹配任意单个字符
- '*' 匹配前一个元素的 0 个或多个

编写递归函数判断字符串是否与模式匹配。

**输入：** 字符串 s，模式 p
**输出：** 布尔值（true 匹配，false 不匹配）
**示例：**
- 输入：s="aa", p="a" → 输出：false
- 输入：s="aa", p="a*" → 输出：true（* 匹配 1 个 a）
- 输入：s="aab", p="c*a*b" → 输出：true
- 输入：s="mississippi", p="mis*is*p*." → 输出：false

**相关概念：** 递归回溯，动态规划，复杂问题分解

---

## 学习建议

1. **简单难度（第一部分）：** 掌握递归的基本结构，理解边界条件和递归调用的概念
2. **中等难度（第二部分）：** 学会在递归中使用更多参数，处理返回值，进行条件判断
3. **高等难度（第三部分）：** 学习回溯法、树遍历等经典递归应用，提高递归思维
4. **困难难度（第四部分）：** 挑战复杂的递归问题，综合运用多种递归技巧

## 学习策略

- **先理解再编码：** 在动手写代码前，用纸笔画出递归树或流程
- **从简到难：** 不要跳过简单题，它们是基础
- **优化递归：** 学会识别和消除递归中的重复计算（记忆化）
- **调试技巧：** 使用打印语句追踪递归调用栈，理解执行顺序
- **对比迭代：** 尝试用迭代实现相同的功能，对比两种方法

---

祝你递归学习之旅顺利！💪
