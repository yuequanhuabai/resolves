
> 我有一个问题，动态代理是编译还是运行是发生的？

● 🎯 动态代理 VS MapStruct 对比

  📋 动态代理：运行时发生

  // JDK动态代理 - 运行时创建
  public class UserServiceProxy {
      public static void main(String[] args) {
          UserService target = new UserServiceImpl();

          // 👇 运行时动态创建代理对象
          UserService proxy = (UserService) Proxy.newProxyInstance(
              target.getClass().getClassLoader(),
              target.getClass().getInterfaces(),
              new InvocationHandler() {
                  @Override
                  public Object invoke(Object proxy, Method method, Object[] args) {
                      System.out.println("方法执行前...");
                      Object result = method.invoke(target, args); // 反射调用
                      System.out.println("方法执行后...");
                      return result;
                  }
              }
          );

          proxy.saveUser(new User()); // 运行时通过反射执行
      }
  }

  🔄 运行时流程

  程序启动 → JVM加载类 → 调用Proxy.newProxyInstance()
  → JVM动态生成字节码 → 创建代理类实例 → 通过反射调用目标方法

  ⚡ MapStruct：编译时发生

  // MapStruct - 编译时生成
  @Mapper
  public interface ConfigConvert {
      ConfigConvert INSTANCE = Mappers.getMapper(ConfigConvert.class);
      ConfigRespVO convert(ConfigDO bean);
  }

  // 编译时自动生成（你看不到源码，但存在于target目录）
  public class ConfigConvertImpl implements ConfigConvert {
      @Override
      public ConfigRespVO convert(ConfigDO bean) {
          // 👇 直接的方法调用，无反射
          ConfigRespVO target = new ConfigRespVO();
          target.setId(bean.getId());
          target.setName(bean.getName());
          return target;
      }
  }

  🔧 编译时流程

  写代码 → Maven/Gradle编译 → MapStruct处理器扫描@Mapper
  → 生成具体实现类 → 编译成字节码 → 运行时直接使用

  📊 详细对比

  | 特性   | 动态代理     | MapStruct |
  |------|----------|-----------|
  | 发生时机 | 🔴 运行时   | 🟢 编译时    |
  | 性能   | 慢（反射调用）  | 快（直接调用）   |
  | 内存占用 | 高（反射对象）  | 低（普通对象）   |
  | 调试难度 | 困难（动态生成） | 容易（有具体类）  |
  | 类型安全 | 运行时检查    | 编译时检查     |
  | 错误发现 | 运行时      | 编译时       |

  🔍 实际验证

  动态代理的运行时特征：

  // 运行时才能看到代理类的真实类名
  Object proxy = Proxy.newProxyInstance(...);
  System.out.println(proxy.getClass().getName());
  // 输出：com.sun.proxy.$Proxy0 （运行时生成的类名）

  MapStruct的编译时特征：

  // 编译后可以在target目录找到生成的类
  // target/generated-sources/annotations/your/package/ConfigConvertImpl.class

  ConfigConvert converter = ConfigConvert.INSTANCE;
  System.out.println(converter.getClass().getName());
  // 输出：your.package.ConfigConvertImpl （编译时生成的固定类名）

  🎯 为什么MapStruct选择编译时？

  1. 性能优势

  // 动态代理：每次调用都要反射
  method.invoke(target, args);  // 慢

  // MapStruct：直接方法调用
  target.setName(source.getName());  // 快

  2. 类型安全

  // 动态代理：运行时才知道错误
  proxy.nonExistMethod();  // 编译通过，运行时报错

  // MapStruct：编译时检查
  convert(wrongTypeObject);  // 编译时就报错

  3. 调试友好

  // 动态代理：调试看到的是Proxy$0，难以理解
  // MapStruct：调试看到的是具体的实现代码，清晰明了

  🚀 其他编译时 VS 运行时的例子

  编译时处理：

  - Lombok: @Data → 编译时生成getter/setter
  - MapStruct: @Mapper → 编译时生成转换器
  - QueryDSL: 编译时生成查询类
  - 注解处理器: 编译时处理注解

  运行时处理：

  - Spring AOP: 运行时创建代理
  - JDK动态代理: 运行时生成代理类
  - CGLIB代理: 运行时生成子类
  - 反射: 运行时访问类信息

  💡 总结

  动态代理 = 运行时 ⏰
  - JVM运行时动态生成字节码
  - 通过反射调用，性能相对较低
  - 灵活性高，可以处理任意接口

  MapStruct = 编译时 🔨
  - Maven/Gradle编译时生成Java源码
  - 直接方法调用，性能接近手写
  - 类型安全，错误编译时发现

  这就是为什么MapStruct比基于反射的BeanUtils性能好那么多的根本原因！

> 我想问一个问题，就是java的类到运行，到底经历了多少个过程，又有哪些过程是可以对代码进行操作的，例如在生成的字节码前后添加
  逻辑等

✻ Thinking…

  用户问的是一个非常好的问题，关于Java从源码到运行的完整生命周期，以及在哪些阶段可以进行代码操作/增强。这是一个比较深入的Java
  技术问题，需要系统性地回答。

  让我组织一下思路：

  1. Java程序的完整生命周期
  2. 每个阶段可以进行的代码操作/增强
  3. 具体的技术和工具
  4. 实际应用场景

  我需要用清晰的图表和例子来说明这个过程。

● 这是一个非常棒的问题！让我详细解释Java代码从编写到运行的完整生命周期，以及每个阶段可以进行的代码操作。

✻ Thinking…

  用户的问题很好，我需要系统地梳理Java代码的生命周期。让我先列出完整的过程：

  1. 源码编写阶段 (.java)
  2. 编译前处理 (注解处理器)
  3. 编译阶段 (.java → .class)
  4. 编译后处理 (字节码增强)
  5. 类加载阶段 (ClassLoader)
  6. 运行时阶段 (JVM执行)

  每个阶段都有不同的代码操作能力，我需要详细说明。

● 🔄 Java代码生命周期全景图

  📝 源码阶段     🔧 编译前       📦 编译阶段      🔬 编译后       🚀 类加载       ⚡ 运行时
     (.java)   → (注解处理器)  → (.class)    → (字节码增强)  → (ClassLoader) → (JVM执行)
       ↓            ↓            ↓             ↓              ↓             ↓
    IDE生成      代码生成       javac编译     字节码操作     类装载/验证    动态代理/反射

✻ Thinking…

  现在我需要详细解释每个阶段的代码操作能力。让我一个一个阶段来分析：

  1. 源码阶段 - IDE工具、代码生成
  2. 编译前 - 注解处理器 (APT)
  3. 编译阶段 - 编译器插件
  4. 编译后 - 字节码操作 (ASM, Javassist等)
  5. 类加载 - ClassLoader, Java Agent
  6. 运行时 - 动态代理, 反射, JVM TI等

  我需要提供具体的技术和代码示例。

● 📝 1. 源码阶段 (.java文件)

  可进行的操作：

  - 代码生成/模板
  - IDE插件增强
  - 代码分析/检查

  技术示例：

  // IDE模板生成代码
  // 输入: pojo + Tab
  public class User {
      private String name;
      private Integer age;

      // IDE自动生成getter/setter/toString等
  }

  // 代码生成器 (如MyBatis Generator)
  // XML配置 → 自动生成DAO、Entity、Mapper等文件

  🔧 2. 编译前阶段 (注解处理器 APT)

  可进行的操作：

  - 扫描注解生成新的Java源文件
  - 编译时检查和验证
  - 元数据收集

  技术示例：

  // Lombok: @Data注解 → 编译前生成getter/setter
  @Data
  public class User {
      private String name;  // 编译前会生成getName()/setName()
  }

  // MapStruct: @Mapper注解 → 编译前生成转换器实现类
  @Mapper
  public interface UserConverter {
      UserConverter INSTANCE = Mappers.getMapper(UserConverter.class);
      UserVO toVO(UserDO user);  // 编译前生成具体实现
  }

  // 自定义注解处理器
  @SupportedAnnotationTypes("com.example.MyAnnotation")
  public class MyProcessor extends AbstractProcessor {
      @Override
      public boolean process(Set<? extends TypeElement> annotations,
                            RoundEnvironment roundEnv) {
          // 扫描@MyAnnotation，生成额外的Java文件
          return true;
      }
  }

  📦 3. 编译阶段 (.java → .class)

  可进行的操作：

  - 编译器插件
  - 语法糖处理
  - 编译优化

  技术示例：

  // 编译器会自动处理语法糖
  List<String> list = Arrays.asList("a", "b");  // 泛型擦除
  for (String item : list) { }  // 编译为迭代器模式
  String str = "Hello " + "World";  // 编译为StringBuilder

  // 编译器插件 (如Error Prone)
  // 在javac编译过程中检查常见错误模式

  🔬 4. 编译后阶段 (字节码增强)

  可进行的操作：

  - 字节码修改/增强
  - AOP织入
  - 性能监控注入

  技术示例：

  ASM 字节码操作：

  // 使用ASM在方法前后添加逻辑
  public class MethodTimingVisitor extends ClassVisitor {
      @Override
      public MethodVisitor visitMethod(int access, String name, String descriptor,
                                     String signature, String[] exceptions) {
          MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);
          return new MethodVisitor(ASM9, mv) {
              @Override
              public void visitCode() {
                  // 在方法开始添加：long start = System.currentTimeMillis();
                  mv.visitMethodInsn(INVOKESTATIC, "java/lang/System",
                                   "currentTimeMillis", "()J", false);
                  mv.visitVarInsn(LSTORE, 1);
                  super.visitCode();
              }

              @Override
              public void visitInsn(int opcode) {
                  if (opcode == ARETURN || opcode == RETURN) {
                      // 在return前添加：System.out.println("耗时:" + (System.currentTimeMillis() - start));
                  }
                  super.visitInsn(opcode);
              }
          };
      }
  }

  AspectJ 编译时织入：

  @Aspect
  public class LoggingAspect {
      @Around("@annotation(Log)")
      public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
          long start = System.currentTimeMillis();
          Object result = joinPoint.proceed();
          long duration = System.currentTimeMillis() - start;
          System.out.println("方法 " + joinPoint.getSignature() + " 耗时: " + duration + "ms");
          return result;
      }
  }

  // 使用AspectJ编译器 (ajc) 在字节码中织入切面逻辑

  🚀 5. 类加载阶段 (ClassLoader)

  可进行的操作：

  - 类加载拦截
  - 字节码动态修改
  - 类热替换

  技术示例：

  Java Agent:

  // premain方式 - JVM启动时加载
  public class MyAgent {
      public static void premain(String agentArgs, Instrumentation inst) {
          inst.addTransformer(new ClassFileTransformer() {
              @Override
              public byte[] transform(ClassLoader loader, String className,
                                    Class<?> classBeingRedefined,
                                    ProtectionDomain protectionDomain,
                                    byte[] classfileBuffer) {
                  if (className.equals("com/example/MyClass")) {
                      // 动态修改字节码
                      return enhanceClass(classfileBuffer);
                  }
                  return null;
              }
          });
      }
  }

  // 启动参数：java -javaagent:myagent.jar MyApp

  自定义ClassLoader:

  public class CustomClassLoader extends ClassLoader {
      @Override
      protected Class<?> findClass(String name) throws ClassNotFoundException {
          byte[] classData = loadClassData(name);
          // 可以在这里修改字节码
          byte[] enhancedData = enhanceClass(classData);
          return defineClass(name, enhancedData, 0, enhancedData.length);
      }
  }

  ⚡ 6. 运行时阶段 (JVM执行)

  可进行的操作：

  - 动态代理
  - 反射操作
  - 热部署
  - 性能监控

  技术示例：

  JDK动态代理:

  // 运行时创建代理类
  UserService proxy = (UserService) Proxy.newProxyInstance(
      UserService.class.getClassLoader(),
      new Class[]{UserService.class},
      (proxy1, method, args) -> {
          System.out.println("调用方法前: " + method.getName());
          Object result = method.invoke(target, args);
          System.out.println("调用方法后: " + method.getName());
          return result;
      }
  );

  CGLIB动态代理:

  // 运行时生成子类
  Enhancer enhancer = new Enhancer();
  enhancer.setSuperclass(UserService.class);
  enhancer.setCallback(new MethodInterceptor() {
      @Override
      public Object intercept(Object obj, Method method, Object[] args,
                            MethodProxy proxy) throws Throwable {
          System.out.println("CGLIB拦截: " + method.getName());
          return proxy.invokeSuper(obj, args);
      }
  });
  UserService proxy = (UserService) enhancer.create();

✻ Thinking…

  现在我需要提供更多实际的技术和工具示例，以及对比分析这些技术。让我整理一个完整的技术对比表和实际应用场景。

● 🛠️ 各阶段主要技术和工具对比

  | 阶段   | 主要技术                   | 典型应用              | 性能影响 | 复杂度 |
  |------|------------------------|-------------------|------|-----|
  | 源码阶段 | IDE插件、代码生成器            | MyBatis Generator | 无    | 低   |
  | 编译前  | APT、Lombok、MapStruct   | @Data、@Mapper     | 无    | 中   |
  | 编译后  | ASM、Javassist、AspectJ  | AOP织入             | 无    | 高   |
  | 类加载  | Java Agent、ClassLoader | 监控、热部署            | 低    | 高   |
  | 运行时  | 动态代理、反射                | Spring AOP        | 中    | 中   |

  🎯 实际应用场景举例

  Spring框架的多阶段增强：

  // 1. 编译前：@Autowired等注解 (编译时不处理，运行时处理)
  @Service
  public class UserService {
      @Autowired
      private UserRepository userRepository;  // 运行时注入

      // 2. 编译后/运行时：@Transactional AOP增强
      @Transactional
      public void saveUser(User user) {
          userRepository.save(user);
      }
  }

  // Spring启动时的处理流程：
  // 1. 扫描@Service注解 (运行时反射)
  // 2. 创建@Transactional的代理对象 (运行时动态代理)
  // 3. 处理@Autowired依赖注入 (运行时反射)

  性能监控的多阶段实现：

  // 方案1：编译时APT注解处理器
  @PerformanceMonitor
  public class OrderService {
      public void processOrder() { } // 编译时生成监控代码
  }

  // 方案2：编译后字节码增强 (如SkyWalking)
  // 无需修改源码，自动在方法前后添加监控逻辑

  // 方案3：运行时动态代理 (如Spring AOP)
  @Component
  @Aspect
  public class PerformanceAspect {
      @Around("@annotation(PerformanceMonitor)")
      public Object monitor(ProceedingJoinPoint joinPoint) { }
  }

✻ Thinking…

  现在我需要总结回答用户的核心问题，整理一个清晰的总结。用户主要想了解：
  1. Java类到运行经历了哪些过程
  2. 哪些过程可以对代码进行操作
  3. 如何在生成字节码前后添加逻辑

  我已经详细解释了各个阶段，现在需要一个清晰的总结。

● 🔥 核心字节码增强技术深入

  编译后字节码操作 - ASM实战：

  // 原始代码
  public class Calculator {
      public int add(int a, int b) {
          return a + b;
      }
  }

  // ASM增强：在方法前后添加日志
  public class CalculatorEnhancer {
      public static void main(String[] args) throws Exception {
          ClassReader cr = new ClassReader("Calculator");
          ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);
          ClassVisitor cv = new ClassVisitor(ASM9, cw) {
              @Override
              public MethodVisitor visitMethod(int access, String name, String descriptor,
                                             String signature, String[] exceptions) {
                  MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);
                  if ("add".equals(name)) {
                      return new MethodVisitor(ASM9, mv) {
                          @Override
                          public void visitCode() {
                              super.visitCode();
                              // 添加：System.out.println("方法开始执行");
                              mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
                              mv.visitLdcInsn("方法开始执行");
                              mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println",
  "(Ljava/lang/String;)V", false);
                          }

                          @Override
                          public void visitInsn(int opcode) {
                              if (opcode == IRETURN) {
                                  // 在return前添加：System.out.println("方法执行结束");
                                  mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");
                                  mv.visitLdcInsn("方法执行结束");
                                  mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println",
  "(Ljava/lang/String;)V", false);
                              }
                              super.visitInsn(opcode);
                          }
                      };
                  }
                  return mv;
              }
          };
          cr.accept(cv, 0);

          // 生成增强后的字节码
          byte[] enhancedCode = cw.toByteArray();
          Files.write(Paths.get("Calculator.class"), enhancedCode);
      }
  }

  Java Agent 运行时增强：

  // Agent入口
  public class TimingAgent {
      public static void premain(String agentArgs, Instrumentation inst) {
          inst.addTransformer(new TimingTransformer());
      }
  }

  // 字节码转换器
  public class TimingTransformer implements ClassFileTransformer {
      @Override
      public byte[] transform(ClassLoader loader, String className,
                            Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
                            byte[] classfileBuffer) throws IllegalClassFormatException {

          if (className.startsWith("com/mycompany")) {  // 只增强特定包
              return addTimingCode(classfileBuffer);
          }
          return null;
      }

      private byte[] addTimingCode(byte[] originalCode) {
          // 使用ASM在每个方法前后添加计时逻辑
          ClassReader cr = new ClassReader(originalCode);
          ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);
          // ... ASM代码增强逻辑
          return cw.toByteArray();
      }
  }

  // 使用方式：java -javaagent:timing-agent.jar MyApp

  📊 性能对比 & 选择指南

  性能影响排序（从低到高）：

  1. 编译前 (APT) - 无运行时影响 ⭐⭐⭐⭐⭐
  2. 编译后 (ASM) - 无运行时影响 ⭐⭐⭐⭐⭐
  3. 类加载 (Agent) - 轻微启动影响 ⭐⭐⭐⭐
  4. 运行时 (动态代理) - 每次调用都有开销 ⭐⭐⭐

  技术选择建议：

  // 场景1：对象转换 → 选择编译前APT
  @Mapper  // MapStruct - 编译时生成，运行时零开销
  public interface UserConverter { }

  // 场景2：全局监控 → 选择Java Agent
  // SkyWalking, Pinpoint等APM工具

  // 场景3：业务AOP → 选择运行时代理
  @Transactional  // Spring - 运行时动态代理
  public void businessMethod() { }

  // 场景4：性能关键场景 → 选择编译后字节码增强
  // 直接修改.class文件，无运行时开销

  💡 总结回答

  Java代码生命周期的6个关键阶段：

  1. 📝 源码阶段 - IDE工具、代码生成
  2. 🔧 编译前 - 注解处理器 (APT)，如Lombok、MapStruct
  3. 📦 编译阶段 - javac编译，语法糖处理
  4. 🔬 编译后 - 字节码增强 (ASM、Javassist、AspectJ)
  5. 🚀 类加载 - Java Agent、自定义ClassLoader
  6. ⚡ 运行时 - 动态代理、反射操作

  可以"添加逻辑"的核心阶段：

  - 编译前：生成额外源码 (MapStruct生成转换器)
  - 编译后：修改字节码 (ASM添加监控逻辑)
  - 类加载：动态转换字节码 (Java Agent拦截)
  - 运行时：代理拦截方法调用 (Spring AOP)

  最佳实践：根据需求选择合适的阶段进行增强，优先选择编译时方案以获得最佳性能！